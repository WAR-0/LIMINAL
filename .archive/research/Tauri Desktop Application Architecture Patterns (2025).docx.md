# Tauri Desktop Application Architecture Patterns (2025)

## Architecture Pattern Catalog

### Rust Backend Patterns

- **Service & Module Organization**: Successful Tauri apps structure Rust backend logic into clear modules or services. For example, _Spacedrive_ isolates core functionality in a Rust library (sdcore) that handles filesystem, database, and networking, which can be reused across apps[\[1\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=,a%20variety%20of%20host%20applications). This separation of concerns makes the backend a self-contained “engine” that the Tauri app calls into. Organize code by feature (e.g. file system ops, process management, updater) and expose a clean API to the frontend via Tauri commands.

- **State Management**: Global state is managed in the Core (Rust) process so it can be shared safely across windows[\[2\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=The%20Core%20process%20should%20also,prying%20eyes%20in%20the%20Frontend). Tauri’s manage() API lets you store state (often wrapped in Arc\<Mutex\<T\>\> or just Mutex\<T\>) that commands can access[\[3\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=use%20std%3A%3Async%3A%3AMutex%3B)[\[4\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=%2F%2F%20). For instance, a global State\<Counter\> with an inner Mutex\<i32\> allows synchronized updates from any thread or window[\[5\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=Mutex%20is%20a%20practical%20way,security%20of%20the%20shared%20data)[\[6\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=use%20tauri%3A%3AState%3B). Many apps treat the frontend as a “view” or control surface, keeping critical state (settings, data models, long-running status) in Rust. This avoids inconsistent state in multiple React/Svelte stores. A Reddit discussion by Tauri devs recommends **“store Tauri state in a mutex, access via IPC; treat frontend as a control surface.”**[\[7\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=%E2%80%A2%20%201mo%20ago%20,%E2%80%A2%20Edited%201mo%20ago). In practice, apps like _Pomatez_ use static Mutexes for state (e.g. window size, mode flags) to ensure thread-safe updates from commands[\[8\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L26-L34)[\[9\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L156-L165).

- **Command Design**: Tauri commands (Rust functions exposed to JS) are typically small, focused units of work. Complex apps group commands logically – e.g., _Pomatez_ defines all window-management commands in a commands.rs and registers them via a helper trait for cleaner builder code[\[10\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L232-L240)[\[11\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L234-L242). Commands may be synchronous or asynchronous. **Async commands** (declared with async fn) are preferred for heavy tasks so as not to block the main thread[\[12\]](https://v2.tauri.app/develop/calling-rust/#:~:text=Section%20titled%20%E2%80%9CAsync%20Commands%E2%80%9D). In Tauri v1, non-async commands run on the main thread, whereas async commands are executed on a separate runtime thread[\[13\]](https://v2.tauri.app/develop/calling-rust/#:~:text=Note). For example, a file reading command should be async to prevent UI freeze. If borrowing issues arise with async (due to \&str or State lifetimes), convert to owned types or use workarounds as noted in Tauri docs[\[14\]](https://v2.tauri.app/develop/calling-rust/#:~:text=If%20your%20command%20needs%20to,async).

- **Error Handling**: Robust Tauri backends use Result\<OkType, ErrType\> returns in commands to propagate errors to the frontend. If a command returns an Err, the JS invoke() Promise is rejected, letting the frontend handle it gracefully[\[15\]](https://v2.tauri.app/develop/calling-rust/#:~:text=If%20the%20command%20returns%20an,will%20reject%2C%20otherwise%2C%20it%20resolves). Since error types must be serializable (implement Serialize), many projects convert errors to strings or use an error enum with thiserror for friendly messages[\[16\]](https://v2.tauri.app/develop/calling-rust/#:~:text=serde%3A%3ASerialize%2C%20including%20errors,String)[\[17\]](https://v2.tauri.app/develop/calling-rust/#:~:text=%2F%2F%20create%20the%20error%20type,errors%20possible%20in%20our%20program). For instance, Tauri docs show mapping std::io::Error to a custom serializable error type[\[18\]](https://v2.tauri.app/develop/calling-rust/#:~:text=fn%20my_custom_command%28%29%20,)[\[19\]](https://v2.tauri.app/develop/calling-rust/#:~:text=enum%20Error%20). Best practice is to design a clear error enum with variants (possibly carrying codes) and serialize it to a structured JS object[\[20\]](https://v2.tauri.app/develop/calling-rust/#:~:text=)[\[21\]](https://v2.tauri.app/develop/calling-rust/#:~:text=fn%20read%28%29%20,), so the frontend can react based on error kind.

- **Concurrency & Async Patterns**: Rust’s async and multi-threading capabilities are used to keep the app responsive. Long-running tasks (like monitoring, background computations) are often run on separate threads or via tauri::async_runtime::spawn[\[22\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=let%20twitch_chat_app_handler%20%3D%20handle)[\[23\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=). For example, a Tauri Twitch chat app spawns an async task to listen to incoming messages and uses Tauri’s event system to push updates to the UI[\[24\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=)[\[25\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=let%20join_handle%20%3D%20async_runtime%3A%3Aspawn,). Many apps use Rust’s channels or Tauri events instead of continuous polling. Shared data can be updated in these background threads (guarded by Mutex or message passing) and the UI notified via events.

- **Database Integration**: Tauri apps often embed lightweight databases for local storage. Patterns include bundling SQLite or using file-based stores. For instance, the _Orion_ project (a Tauri-based AI assistant app) uses a local SQLite DB to store chat history[\[26\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=One%20of%20Orion%27s%20key%20features,an%20ideal%20choice%20for%20Orion). They create the DB file at a known location (e.g. \~/.config/APP/database.sqlite) on startup[\[27\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=To%20handle%20the%20creation%20and,file%20with%20the%20following%20functions)[\[28\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=the%C2%A0,Here%27s%20how%20to%20do%20it). The Rust side can use ORM-like crates (Diesel, SeaORM) or raw SQL (e.g. with rusqlite). A common approach is to open a single DB connection and store it in Tauri state (manage() it) so all commands can access it[\[29\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=days%20ago%2C%20I%20found%20in,when%20building%20applications%20with%20Tauri)[\[30\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=Let%27s%20open%20the%20file%20,by%20default%20has%20this%20structure). This avoids constantly reopening the DB and ensures thread safety via a Mutex\<Connection\> or connection pool. If using an ORM, make sure it’s Send across threads or stick to synchronous methods inside an async command. Some projects also leverage Tauri’s plugin-sql for simpler use cases, which executes SQL queries from the frontend through a safe API[\[31\]](https://crates.io/crates/tauri-plugin-state#:~:text=tauri,to%20keep%20it%20in%20sync). The key is to keep database operations on the Rust side for performance and security, and use front-end only for displaying data or sending queries.

- **File System & Security**: Accessing the file system is a core use of Rust in Tauri. Patterns include using Tauri’s built-in _FS scope_ (which limits accessible directories for security) and using Rust’s std::fs for actual reads/writes. For example, _Orion_ ensures the directory exists and then creates the file via fs::create_dir_all and File::create in Rust[\[32\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=fn%20create_db_file%28%29%20,unwrap). This kind of initialization is done in tauri::Builder.setup() so it runs early in app startup[\[33\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=mod%20db%3B). When exposing file data to the UI, consider streaming large files in chunks or using the Path API (e.g., have Rust give the UI a temp file path to load, rather than sending a huge blob over IPC). Always validate paths in Rust (Tauri’s API can enforce allowed paths in tauri.conf.json). Use tauri::api::dialog or Dialog APIs for user to choose files rather than trusting arbitrary paths. Some apps implement file watchers using Rust’s notify crate in a background thread to monitor changes and then emit events to the UI.

- **External Process Management**: Tauri’s Rust backend can spawn and manage child processes for heavy tasks or integrations. A common pattern is to use tauri::Command or the shell plugin to launch processes in a controlled way. For example, an app might spawn a long-running CLI tool and capture its stdout. Tauri offers a shell plugin (tauri-plugin-shell) which can spawn a child with arguments and even read output streams asynchronously[\[34\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=). Ensure you kill child processes on app exit (there have been issues on Windows where spawned children persist if not killed[\[35\]](https://github.com/tauri-apps/tauri/issues/4949#:~:text=,child%20process%20continues%20to%20run)). For process orchestration, maintain a list of child PIDs/handles in a global state so you can send termination signals or check statuses. If coordinating multiple external processes (like orchestrating microservices or agents), consider using a manager service in Rust: spawn each process, read their outputs (perhaps in separate threads), and use Tauri events to update the UI about each process’s status. **Single-instance enforcement** is also a consideration: Tauri’s SingleInstance plugin can prevent launching duplicate app instances[\[36\]](https://v2.tauri.app/concept/architecture/#:~:text=,121), which is useful if the app already has background processes running.

### Frontend Integration Patterns

- **Framework-Agnostic Approach**: Tauri supports any frontend (React, Svelte, Vue, Angular, or even vanilla JS). The integration pattern is similar: the frontend is essentially a web app that communicates with Rust via the Tauri JS API. Key integration points are the Tauri invoke function for commands and the event listener for backend events. Regardless of framework, it’s wise to encapsulate Tauri calls in a service layer or hooks.

- **React \+ Tauri**: Many Tauri apps use React (often with Vite or CRA). In React, a common pattern is to create custom Hooks or Contexts for Tauri interactions. For example, you might have a useBackend() hook that provides functions to call Rust commands (using @tauri-apps/api) and to subscribe to events. State management in React for Tauri apps can leverage libraries like **Zustand** or **Redux** for complex state, but be mindful of duplicating state already in Rust. Some teams use Zustand to manage local UI state and also mirror some global state from Rust by fetching it on launch. A Reddit thread noted that Zustand works well and some even created a library to sync Zustand with Tauri state[\[37\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=As%20title%20states%2C%20I%E2%80%99m%20building,I%20have)[\[38\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=ferreira). In practice, React apps often initialize by calling a Rust command (e.g. get_initial_state) in a useEffect and storing that in React state. Subsequent updates from Rust might come via events, which in React can be handled by registering an event listener on mount (and cleanup on unmount) and using setState or context dispatch to update the UI. If multiple React components need data from Rust, lift that state to a top-level context or use something like Recoil or Zustand for shared global state.

- **Svelte \+ Tauri**: Svelte’s reactivity pairs nicely with Tauri’s event-driven model. The typical pattern is to use Svelte stores to hold app state and update them when Rust events come in. For example, a Svelte store could represent a list of “agents” or processes with their statuses; when the Rust backend emits an event like agent-status, the event handler in JS updates the Svelte store, automatically reflecting in the UI. Svelte’s onMount can call Tauri commands to fetch initial data. There are community templates combining Tauri \+ SvelteKit. One advantage is Svelte’s small footprint aligns with Tauri’s goal of small bundles. _Tauri Studio_ (the official Tauri dev tool, if referenced) and many official examples use Svelte \+ Vite[\[39\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=This%20means%20that%20most%20of,framework%20and%20the%20Vite%20bundler). They demonstrate patterns like creating a tauri.ts utility to wrap invoke calls and using Svelte’s tick or $: reactivity to respond to changes. Svelte stores (writable stores) can also directly call invoke inside, e.g., an action that updates a Rust state and then updates the store when a response comes back.

- **Vue \+ Tauri**: Vue 3 with Composition API can integrate with Tauri by using composables. A common pattern is to create a useTauri() composable that provides methods to call commands and listen to events (possibly using window.\_\_TAURI\_\_.event.listen). In components, you might use onMounted to call Rust for data. Vue’s reactivity means you can bind UI elements to data that gets updated by Rust events. For example, an app might call a Rust command to start a background operation, and the Rust side emits progress events. Using tauri.event.listen('progress', callback) in a Vue onMounted hook can update a reactive property progressValue, which the template binds to a progress bar. Vue developers also leverage Vuex or Pinia for state management if the app is complex, but again ensure any critical single-source-of-truth (like user data, config) stays in Rust or is at least persisted (Vuex state would reset on refresh unless synced via Tauri’s store plugin or saved to disk).

- **Vanilla JS \+ Tauri**: Some simpler apps or those using lightweight frameworks stick to plain JS/TS. In this case, integration means directly calling window.\_\_TAURI\_\_.invoke or using the Tauri API package. The pattern here is to structure your script to register event listeners early and perhaps use a pub-sub model. Without a framework’s state management, you might manipulate the DOM or use a lightweight library (even just events). For example, _Bruno_ (API client) uses React, but if it were vanilla, it might organize code such that on startup it calls invoke('loadCollections') and then renders the UI with the returned data. Vanilla setups often attach listeners to buttons that call invoke('command', {args}) and handle results via Promises. The key is ensuring asynchronous Rust calls don’t block UI – always use the promise callbacks to update the DOM when ready, so the UI remains responsive.

- **Frontend Routing & Multiple Views**: Apps with multiple pages (or multi-window) often use front-end routing (like React Router or Vue Router) for single-window apps. For multi-window, each window might simply load a different HTML or route. For example, a Tauri app can define multiple windows in tauri.conf.json each pointing to a different HTML entry (like index.html for main, settings.html for a settings window). Alternatively, one could use a single-page app and conditionally render different “pages” – the choice depends on complexity. _Pomatez_ uses React Router (evidenced by routes in its source) to handle different sections of the app in a single window.

- **UI Libraries & Components**: Using component libraries (e.g. Material-UI for React, Element Plus for Vue, etc.) is common and works as usual – just be mindful of bundle size. Some Tauri apps prefer headless UI libraries or OS-native styling to make the app feel native (e.g., using system titlebars, as Pomatez allows toggling between custom and native titlebar[\[40\]](https://github.com/zidoro/pomatez#:~:text=%2A%20Progress%20animation%20,disable%20it%20by%20the%20way)). For performance, avoid extremely heavy front-end libraries, since one goal is to keep memory low. Lightweight state libraries (Zustand for React, Pinia for Vue, Svelte’s builtin stores) often suffice.

### IPC Communication Patterns

- **Commands vs. Events**: Tauri offers two primary IPC mechanisms: **commands** (request/response) and **events** (publish/subscribe). Pattern: use **commands** for one-off requests that expect a result (like “get data”, “perform action and return status”) and use **events** for real-time or push updates (“notify UI of new log entry”, “progress update”). Most complex apps use a mix. For example, a “Scan Files” feature might be initiated by a command (to start scanning), and the backend continuously emits events like scan-progress with updates, finally maybe an event scan-complete with summary. The frontend would call invoke('start_scan') then listen via event.listen('scan-progress', ...) to update a progress bar. This decoupling keeps the UI reactive to backend changes without polling.

- **Synchronous vs. Asynchronous Commands**: By default, invoke is async (returns a Promise). Tauri does support invokeSync in some contexts, but it’s rarely needed – blocking the renderer for a sync response is usually an anti-pattern. Instead, even if using a command for something quick, treat it as async. For critical quick calls, you can still use a normal invoke and handle the Promise. Only use sync (which actually just hides the async under the hood) for trivial operations where you absolutely need the result immediately during, say, initialization (but even then, better to await the promise).

- **Data Serialization**: Tauri IPC uses JSON for payloads by default (via serde::Serialize/Deserialize). Most apps stick with JSON as it’s convenient and human-readable. When sending complex data (e.g., a list of structured items), define a Rust struct, derive Serialize, and have the JS receive it as an object/array. For large binary data, consider alternatives: e.g., send file paths or use base64 encoding if you must send via JSON (not efficient for huge binaries). Tauri v2 has features like Response::new(data) that can transfer binary data[\[41\]](https://v2.tauri.app/develop/calling-rust/#:~:text=fn%20read_file%28%29%20), but remember that JSON stringification might bloat it. In such cases, writing to a temp file and sending the path might be better.

- **Error Propagation**: As noted, return Result in commands so that errors surface to the frontend cleanly[\[42\]](https://v2.tauri.app/develop/calling-rust/#:~:text=If%20your%20handler%20could%20fail,Result)[\[15\]](https://v2.tauri.app/develop/calling-rust/#:~:text=If%20the%20command%20returns%20an,will%20reject%2C%20otherwise%2C%20it%20resolves). Establish a convention for error formats – e.g., always return Err(String) with a user-friendly message (and log the detailed error on Rust side). Some apps define error _codes_: e.g., an error enum serialized to { kind, message }[\[20\]](https://v2.tauri.app/develop/calling-rust/#:~:text=)[\[21\]](https://v2.tauri.app/develop/calling-rust/#:~:text=fn%20read%28%29%20,), and the frontend can switch on error.kind to handle specific cases (like if (error.kind \=== 'Network') { showReconnectPrompt(); }). This mimics how Electron’s IPC or HTTP APIs are handled and makes error handling more robust.

- **Event Handling**: Tauri events can be global or window-specific. **Global events** (emitted via AppHandle.emit_all) go to all windows[\[43\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=The%20Core%27s%20primary%20responsibility%20is,messages%20in%20one%20central%20place), which is useful for broadcasting updates (e.g., “user-logged-in” event that multiple windows might need). _Pomatez_ uses a global event to update its tray icon state across the app[\[44\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L240-L248) (see tray_icon_update command being invoked which internally likely emits event to refresh icon). **Window events** (emitted to a specific window) are used when only one UI context needs the info (e.g., sending data to a hidden window or a particular child window). In the frontend, unsubscribing from events on component unmount is important to avoid memory leaks (Tauri’s API returns an unlisten function).

- **Real-time Streaming**: For truly high-frequency data (like logs, live metrics), flooding events could overwhelm IPC. In such scenarios, consider batching updates (e.g., send one event per second with multiple data points rather than 100 events per second). Another pattern is using a persistent connection: Tauri provides a WebSocket plugin for real-time streams[\[45\]](https://v2.tauri.app/concept/architecture/#:~:text=,About), or one can even start a localhost server (with Actix or similar) and use websockets. But usually, Tauri events suffice. For example, a system monitor app might emit CPU/RAM stats on an interval; the UI listens and updates charts. If the volume is high, keep payloads minimal (binary or numeric data, not huge JSON).

- **Batch Operations**: When the front-end needs to request a large dataset from Rust (e.g., thousands of records from a DB), a pattern is to provide a filtering or pagination mechanism in the command. Instead of returning 10,000 items at once, the Rust command could accept parameters like offset and limit, or a query string, and return a chunk. The UI can then fetch sequentially or on demand. This avoids JSON serialization of massive payloads in one go. If a truly large transfer is needed (like exporting data), consider writing it to a file and then using Tauri’s invoke to notify when ready (the UI can then prompt the user to open/save that file).

- **Security Considerations**: All IPC should treat inputs as potentially untrusted (especially if your app loads any remote content or could be exposed to plugins). Use Tauri’s _IPC scope_ configuration to restrict which commands can be called from the frontend (Tauri v2 allows specifying an allowlist of IPC calls). Also, validate any data coming from the UI in Rust (types help here, but e.g., if a path is passed in, ensure it’s within an allowed directory).

- **Type-Safe IPC**: Some projects adopt libraries like **rspc** (Rust RPC) to generate typesafe bindings between Rust and TS. _Spacedrive_ uses rspc to define Rust functions that can be called from TS with full type checking[\[46\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=on%20macOS%2C%20thanks%20to%20Safari%E2%80%99s,integration%20with%20the%20operating%20system)[\[47\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=rspc%3A%20The%20project%20utilizes%20rspc%2C,bugs%20making%20it%20into%20production). This pattern improves maintainability: the API between frontend and backend is defined in one place and checked by the compiler. It’s akin to tRPC but for Tauri. This can be overkill for small apps but shines in large projects with many IPC calls. In absence of such a library, documenting the interface (list of commands and events, with payload schemas) is good practice.

### Complex Desktop App Features

- **Multiple Windows**: Tauri natively supports multi-window apps with one Rust core managing many WebView processes[\[48\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=flowchart%20TD%20C,Events%20%26%20Commands%7C%20W3). Patterns for multi-window include defining static windows in the tauri.conf.json or creating them dynamically at runtime via WindowBuilder. If your app needs multiple windows (e.g. separate UI for different agents or a settings panel), design a clear communication scheme: either each window independently calls Rust (preferred, using the core as the intermediary), or windows communicate via the core using events (Window A emits an event that the Rust core forwards to Window B). **State synchronization** is straightforward because the Rust core can hold global state accessible by all windows[\[2\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=The%20Core%20process%20should%20also,prying%20eyes%20in%20the%20Frontend). For example, you might use app.emit_to("otherWindow", "event-name", payload) to send an event to another window. _Electron vs Tauri_: Unlike Electron (where each BrowserWindow has its own process and duplicative state), Tauri windows are lighter – the Rust state is single-instance. As one Tauri dev noted, this avoids the issue of state duplication across windows and keeps memory usage low[\[49\]](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6#:~:text=Most%20desktop%20apps%20fail%20to,scale%20because). When implementing multi-window, also handle window lifecycles: ensure closing one window doesn’t quit the app if others are open (Tauri has a prevent_close or you manage app.exit manually). Use the **Window Label** to reference specific windows in code, and store those labels if needed (though you can always get windows via the AppHandle).

- **System Tray & Background Operation**: Many desktop apps (Pomatez, VPN clients, etc.) minimize to a system tray for continued background operation. Tauri provides a tray API – pattern: create the tray icon and menu in the Rust setup() and handle tray events (clicks, menu selections) to perform actions[\[50\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L44-L52). For instance, _Pomatez_ enables “minimize to tray” and “close to tray” behaviors[\[51\]](https://github.com/zidoro/pomatez#:~:text=running%20on%20your%20Operating%20System): their Rust code intercepts the window minimize/close commands to hide the window instead of truly closing[\[52\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L34-L42)[\[53\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L44-L50). They define a custom close_window command that checks a setting (close_to_tray) and either hides the window or closes it[\[54\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L42-L50). This pattern—interposing logic on window events—creates a smooth UX. Use the SystemTray struct to define tray menu items (like "Open", "Quit") and use tray_icon_update events to reflect app state (e.g., change icon when work timer is active, as Pomatez does via a command that updates the tray icon[\[44\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L240-L248)). Tray integration also allows the app to run without any visible window (just a tray icon) if needed.

- **File System Watchers**: Apps like _Spacedrive_ likely need to monitor directories. A common Rust pattern is using the notify crate to watch directories for changes. You can spawn a thread on startup that watches important folders (or user-designated ones) and then emit events like file-changed to the frontend when something happens. Because Tauri is a long-running process, such watchers persist as long as the app is open. Ensure to deal with debounce (multiple rapid events) and to stop watchers on app exit (though they end with process). If the app uses a database index (like Spacedrive’s VDFS index[\[55\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=,storage%20capacity%20and%20processing%20power)), then file events might trigger DB updates on the Rust side without needing to spam the UI.

- **Native OS Integrations**: Tauri exposes many OS features via either core APIs or plugins: e.g., notifications, global shortcuts, open-with, device info, etc. _Pomatez_ uses tauri_plugin_autostart to register itself to launch on startup on macOS and Windows[\[56\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L28-L36), and tauri_plugin_notification for triggering system notifications[\[57\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L30-L37). These plugins abstract OS specifics into easy calls. Pattern: use official plugins where possible for things like Notifications, OS tray, Updater, etc., as they handle cross-platform nuances. For instance, global shortcuts: register them in Rust (as Pomatez does in setup_global_shortcuts and uses a register_global_shortcuts() on app ready[\[50\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L44-L52)[\[58\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L58-L66)). Then, have those triggers call Tauri commands or emit events (e.g., a global hotkey for “Pause Timer” could directly invoke the same Rust logic as a button press).

- **Auto-Updates**: Tauri has a built-in Updater plugin. The pattern in production apps is to enable the updater in tauri.conf.json and optionally call check_update from JS (or let it auto-check). For example, _Pomatez_ activates the updater plugin only if enabled in config[\[59\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L38-L46) and provides commands check_for_updates and install_update that likely wrap the plugin’s functionality[\[44\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L240-L248). A good UX pattern is to let the updater download in background and then notify the user (via event or notification) that “Update is ready, restart to apply.” If you have a custom update flow (like downloading from a private server), you might use tauri::api::http to download a file and then use the Updater API to feed it, but usually the built-in mechanism with a JSON release file is sufficient. Always test updates on each platform (signing and permissions can affect auto-update behavior on macOS and Windows).

- **Local Database & Caching**: Many complex apps (note-taking apps, API clients, etc.) use local storage. If not using a full DB, Tauri’s **Store** plugin offers a simple JSON file key-value store[\[60\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=using%20and%20communicating%20it%20with,Thank%20you%20in). Pattern: use it for small config or state persistence between sessions (it’s like Electron’s store or browser localStorage, but stored in an encrypted (optional) file). For larger structured data, use SQLite as mentioned, or even an embedded NoSQL (some have used Sled or RocksDB in Rust).

- **Long-Running Background Tasks**: Running heavy tasks continuously (like a daemon) is achievable by spawning threads in Rust. For example, _Docker Desktop_\-like functionality might monitor Docker APIs continuously. Pattern: spawn a thread in setup() and have it communicate with the main thread via channels or directly emit events. Use thread::spawn or tokio::spawn (if within an async context). One could also create a _background Tauri window_ (headless window with no GUI) if needed to leverage Web APIs or WebWorkers, but generally doing it in Rust is more efficient.

- **Plugin Architecture for Extensibility**: Some advanced apps design plugin systems to allow extending functionality without modifying core code. While not common in small apps, an orchestrator like FORGE might consider it. Patterns could include: a plugin folder where users drop dynamic libraries or scripts that the app loads. Tauri itself has a plugin system (for Rust crates that hook into Tauri’s lifecycle). You could allow JS/TS plugins by loading additional scripts into the webview, but that has security implications. Alternatively, if each “agent” in FORGE is like a plugin, you might isolate them in separate processes or even use Web Workers. In Rust, a safe plugin interface could be a trait object that is loaded via libloading (for advanced use). However, for initial architecture, it might be sufficient to structure the app so adding new agent types or new panels is modular (e.g., via a registration system in code).

### Performance Optimization Patterns

- **Binary Size Optimization**: Tauri’s big win is small bundle size. By using the OS webview, the app doesn’t ship Chromium (vs Electron). Many production Tauri apps are just \~10 MB or less in binary size[\[61\]](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6#:~:text=I%20built%20a%20multi,how%20I%20scaled%20it%20cleanly). To keep size small, avoid adding heavy Cargo dependencies unless necessary (e.g., if you need image processing, consider using small targeted crates). Use release mode builds with LTO (Link Time Optimization) if size is critical. Also minimize the frontend bundle: leverage tree-shaking in your bundler (Vite, Webpack). Remove source maps and unnecessary polyfills in production. In _Spacedrive_’s case, using React \+ Prisma increased the size due to bundling a query engine, but it’s still smaller than an Electron equivalent.

- **Memory Management**: Rust helps by not leaking memory easily, but you should be mindful of caches and global data. Use lazy_static or managed state for caches and periodically clean them if they grow (e.g., if your app caches results in memory). On the frontend, because it’s a WebView, memory usage is similar to a browser tab – avoid holding large DOM elements or massive JS arrays unnecessarily. Tauri apps have been demonstrated to run multi-window with under 50 MB RAM[\[62\]](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6#:~:text=So%20in%202025%2C%20when%20I,and%20I%20haven%E2%80%99t%20looked%20back)[\[63\]](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6#:~:text=With%20just%20Rust%20%2B%20HTML%2FCSS%2FJS%2C,scales%20like%20a%20native%20app). Achieve this by doing heavy work in Rust (which is efficient in memory) and keeping the JS side light. If using React, watch for memory leaks (e.g., don’t leave event listeners dangling as mentioned, and use Chrome dev tools to profile if needed).

- **UI Responsiveness**: The golden rule is to never block the main thread (which in Tauri is the webview’s JS thread and the Rust main thread for non-async commands). Use asynchronous techniques for any non-trivial computation. For instance, if parsing a large JSON in JS, it might freeze the UI – consider offloading it to Rust (where it can be done on a background thread, then return the result). If Rust must do heavy CPU work, you can spawn a dedicated thread so even the Rust event loop isn’t stalled. Use loading indicators in the UI when awaiting responses, but optimize to make those waits short.

- **Startup Time**: Tauri apps start quickly – typically the bottleneck is the frontend loading. To optimize, you can preload critical data. Patterns: use tauri.conf.json \> allowlist \> protocol asset (or assetScope) to serve your files efficiently, and consider enabling the devPath optimization for development (loading from dev server). In production, your HTML/JS/CSS is baked into the Rust binary and loaded from memory – which is quite fast. Still, if your app does a lot on launch (like open DB, scan files, etc.), do it asynchronously or lazily. For example, do not block the tauri::Builder.run() with heavy setup; instead, perform minimal init (maybe just load config) then let the UI show, and perform heavier tasks post-launch (show a splash or loading screen if needed). Also leverage the **splashscreen pattern**: Tauri allows showing an HTML splash window quickly while the main window loads in background, improving perceived startup speed.

- **Resource Usage (CPU)**: If your app updates frequently (e.g., a live graph), throttle the updates. Use setInterval wisely or Rust timers; 60 updates per second may be unnecessary if 1-5 per second is enough. Use Rust’s efficient libraries for heavy computation (e.g., image thumbnail generation with a Rust crate rather than doing it in JS).

- **Optimizing Database Access**: For local databases, batch queries to reduce IPC overhead. If the UI needs 1000 records, a single command that returns 1000 records is better than 1000 commands each returning one (because each IPC call has overhead). If using ORMs, be wary of N+1 query patterns – fetch related data in one go if possible.

- **Asset Management**: Tauri’s build will bundle your assets (icons, images). It compresses and hashes them by default[\[64\]](https://v2.tauri.app/concept/architecture/#:~:text=Section%20titled%20%E2%80%9Ctauri). Ensure large media assets are compressed (use appropriate formats, maybe lazy-load them if not immediately needed). If your app has many large images, consider storing them outside the binary (maybe download on first run or package separately) to keep the binary lean.

- **Profiling and Benchmarking**: In a complex app, it’s worth profiling both the Rust side (use cargo build \--release and tools like perf or Windows Performance Analyzer) and the front-end (Chrome dev tools performance tab) to find bottlenecks. Common culprits for slowdowns: unnecessary re-renders in React, too frequent IPC calls, or heavy synchronous loops in Rust commands.

## FORGE Orchestrator Recommendations

**1\. Recommended Architecture for FORGE (Multi-Agent Coordination)**: Based on the patterns above, FORGE Orchestrator should adopt a **hybrid service-oriented architecture**. The Rust core will act as the orchestrator service, managing multiple agent processes and maintaining global state about those agents. Each “agent” (which could be an external process or an in-process task) can be spawned and supervised by the Rust backend. The core should expose commands like start_agent, stop_agent, get_agent_status etc., and emit events for agent updates (e.g. agent-output, agent-state-changed). This way, the frontend remains a thin layer showing the state and sending user intents (start/stop requests) to the core. Structurally: \- **Rust Core**: A singleton manager (perhaps a struct AgentManager managed as Tauri state) that holds info on all agents (their process handles or thread JoinHandles, their current status, logs, etc.). Use appropriate synchronization (Arc\<Mutex\> or DashMap for concurrent access). The core ensures one agent’s issues don’t crash the UI – if an agent process crashes, the core catches it and emits an event for UI to display a warning. \- **Frontend**: A single-page application (e.g., React/Vue) that presents a dashboard of agents. It subscribes to events like agent-list-updated or agent-log-{id} to update each agent’s panel. The UI triggers commands for user actions (launch a new agent, send input to an agent, terminate agent). Frontend framework choice can be based on team expertise; **React** with hooks (using Zustand for state) would work well if you’re comfortable with it, but **Svelte** would offer simplicity and performance for realtime updates. Given multi-agent status updates can be frequent, Svelte’s reactivity or React’s state management should be fine – just architect to batch updates (e.g., one event carries all changed agent states per tick). \- **IPC Strategy**: Use **structured events** for continuous updates. For example, each agent can have a unique ID; the backend can emit agent-update events with payload {id, state} whenever an agent’s state (running, stopped, error, etc.) changes or periodically emit agent-stats with metrics. For command/control, use Tauri commands that either execute synchronously (quick actions) or spawn tasks. Some commands might immediately return a result (e.g., “failed to start agent”) or simply trigger a process and return, with subsequent updates coming via events. \- **Multi-Window?** Likely FORGE can operate in a single window (multi-panel dashboard). If you foresee needing multiple windows (maybe one per agent for detailed view), you can support that later. Initially, keeping one window simplifies state management. You can still open dialogs or secondary windows for agent detail or logs if needed, using Tauri’s create_window on demand.

**2\. Technology Stack Recommendations**: \- **Frontend Framework**: _React_ (with Vite or CRA) is a solid choice given its ecosystem and the complexity of UI (tables, charts for agent metrics, etc.). Many Tauri apps successfully use React \+ Tailwind or MUI for styling. Alternatively, _Svelte_ can yield a very snappy UI with less code, which might be beneficial for real-time updates. If your team is experienced in React, stick with it – just be mindful of performance (use functional components with memoization where appropriate). If starting fresh and performance and bundle size are top priority, Svelte is worth considering for its minimal overhead. \- **State Management**: In the frontend, use a predictable state container for complex state. **Zustand** (for React) is lightweight and allows creating a global store with actions, which could mirror the Rust state. For example, a Zustand store could have agents: Record\<id, AgentInfo\> and an action to update an agent – the event listener from Rust would call that action. In Svelte, a few Writable stores (one for agent list, maybe one for selected agent details) would suffice. Avoid overly complex state libraries if not needed; Tauri’s backend should be the single source of truth for critical data. \- **Rust Backend Libraries**: Use serde and serde_json for data serialization between Rust and JS. Consider **Tokio** (Tauri v2 uses Tokio internally) for asynchronous tasks if you do network or file I/O for agents. For spawning processes, use std::process::Command or Tauri’s shell API if you need cross-platform convenience (e.g., tauri::api::process::Command can spawn with args easily and read output). If agent processes communicate via stdout, set up asynchronous readers (maybe spawn a thread per process to read lines and emit events). \- **Database/Storage**: If FORGE needs to persist agent configurations or history of runs, integrate SQLite via rusqlite or use the Tauri Store plugin for simpler config. Given multi-agent orchestration, a lightweight DB might be good for storing past executions, logs, etc., which the UI could query (through Rust). \- **UI Component Library**: For a dashboard-like UI, consider a component framework (e.g., **Mantine or MUI** for React, or **Carbon Components** for Svelte/Vue) for consistency and productivity. Ensure it plays well with the styling and doesn’t bloat the bundle excessively.

**3\. IPC Strategy for Real-Time Coordination**: \- Use **event-driven updates**. Each agent process/thread can have a callback or channel to the core that triggers a app.emit_all("agent-update", payload)[\[43\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=The%20Core%27s%20primary%20responsibility%20is,messages%20in%20one%20central%20place). The payload can contain the agent’s ID and either a small diff or full status. Real-time logs from agents can be streamed as events too (but possibly throttle if logs are super verbose – maybe aggregate 10 log lines in one event). \- For controlling agents, define clear command APIs: e.g., start_agent(config) \-\> Result\<AgentInfo, Error\> to launch and immediately return initial info or error, stop_agent(id) \-\> Result\<(), Error\> to stop, send_message(agent_id, msg) if agents accept input, etc. These commands can internally use channels to send messages to the agent threads or OS signals to processes. \- **Type safety**: Define Rust structs for events like:

struct AgentStatus { id: String, status: String, progress: f32, data: Option\<String\> }

and serialize them to JSON for events. On the frontend, use TypeScript to define the matching type. This avoids mistakes in interpreting event payloads. \- If the coordination requires high-frequency messaging or two-way streams (e.g., if agents send a continuous stream of data and expect commands in return rapidly), consider WebSockets via the tauri-plugin-websocket for that specific channel, or implement a simple custom protocol over TCP/IPC between the core and agents. However, this adds complexity – often, events and commands suffice.

**4\. Performance Considerations for Multi-Agent**: \- Each agent you spawn will consume resources. If they are heavy processes (like running AI models or dev servers), ensure the Orchestrator doesn’t become a bottleneck. The Rust core can handle dozens of threads easily, but monitor memory and CPU usage if many agents run concurrently. You might implement a limit or at least warnings if too many are started. \- To keep the UI responsive, do not send extremely frequent updates for all agents simultaneously. For example, instead of each of 20 agents sending an update every 100ms (which would be 200 events/sec), consider aggregating: the core could check all agents and emit one event per second with an array of their statuses. Or each agent emits at a lower frequency unless there’s an important change. \- Utilize asynchronous programming for waiting on processes. For instance, if using Tokio, you can spawn a tokio::process::Command and await its completion in a separate task, without blocking the main thread. When it finishes or produces output, use AppHandle to emit to the UI. \- **Memory**: Keep large data (like logs) out of JS memory if possible. For logs, maybe store them in a file or Rust buffer and only send incremental new lines to UI. If an agent produces huge output, the UI can fetch it on demand (e.g., user clicks “view full log” then a command could retrieve the log from file). \- **Testing Performance**: Simulate having many agents (maybe a dummy agent that just ticks) to see how the system scales. This will inform if you need to adjust update rates or use more efficient data structures.

**5\. Development Workflow**: \- Use Tauri’s dev mode: you can run the frontend dev server (hot reload for React/Vite) and have Tauri load that (via devPath in tauri.conf.json). This allows rapid front-end iteration. Meanwhile, for Rust backend, Tauri does a quick rebuild on code changes (though large Rust code can compile slowly – consider using cargo-watch or just test core logic in isolation with normal Rust tests). \- **Testing**: Write unit tests for your Rust AgentManager logic (without the Tauri part) by structuring it as plain Rust code (e.g., have functions like launch_agent() in a Rust module that you can call in tests). For integration tests, you can use the tauri-driver (WebDriver) to automate the UI if needed[\[65\]](https://v2.tauri.app/develop/tests/webdriver/ci/#:~:text=Continuous%20Integration%20,built%20together%20and%20GitHub), but as the question suggests, focus on core logic and maybe a few manual end-to-end tests. Ensuring that starting/stopping agents works reliably is critical. \- **CI/CD**: Set up GitHub Actions with the Tauri action to build releases for Windows, macOS, Linux[\[66\]](https://v2.tauri.app/distribute/pipelines/github/#:~:text=GitHub%20,query%20the%20newly%20created)[\[65\]](https://v2.tauri.app/develop/tests/webdriver/ci/#:~:text=Continuous%20Integration%20,built%20together%20and%20GitHub). This will catch any platform-specific issues (like path differences or process handling differences). Use tauri-action which can automate making installers and artifacting them. \- **Cross-Platform Differences**: Test the orchestrator on all OSes for things like process control (the way you terminate a process on Windows vs Unix signals differs). Tauri provides some abstraction, but you might need cfg\!(target_os) in Rust for any platform tweaks. Also, if using system tray or autostart, verify those on each platform (e.g., autostart on macOS uses LaunchAgent vs registry on Windows – the plugin handles it[\[56\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L28-L36), but test anyway).

By adopting this architecture – a strong Rust core for multi-agent orchestration and a decoupled reactive frontend – FORGE Orchestrator will be scalable, responsive, and maintainable. The patterns from modern Tauri apps (event-driven updates, global state in Rust, plugin use for system features) directly address the needs of coordinating multiple agents in real time.

## Implementation Roadmap

**Phase 1: Foundation** – _Core architecture setup_  
\- **Project Setup**: Initialize the Tauri project with your chosen frontend framework (create-tauri-app can scaffold with React/Vue/Svelte). Set up Rust project structure: e.g., an agents module for managing agent processes and a commands module for Tauri commands. Establish basic IPC: define a few test commands and events to ensure frontend-backend communication works (e.g., a “ping” command or a test event on interval).  
\- **Single Agent Management**: Implement the ability to start one agent process/thread. For example, get a simple dummy agent running (maybe it’s just a subprocess that prints timestamps, or a thread that increments a counter). Develop the Rust AgentManager with methods start_agent(config), stop_agent(id), and track one agent. The frontend should have a basic interface to trigger these and display the agent’s status. Focus on getting the lifecycle correct (spawn, observe output, stop, handle termination).  
\- **State & IPC Mechanism**: Use Tauri’s State to manage the AgentManager globally[\[2\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=The%20Core%20process%20should%20also,prying%20eyes%20in%20the%20Frontend). Implement event emission for agent status. At this phase, it could be as simple as emitting “agent-started” or “agent-stopped” events. Ensure the frontend receives and handles these (log to console or simple UI updates).  
\- **Error Handling**: Add error propagation for, say, if an agent fails to start. Use Result in the start/stop commands and test that the frontend can catch and display an error (e.g., try launching an invalid process and ensure error flows through[\[67\]](https://v2.tauri.app/develop/calling-rust/#:~:text=)[\[15\]](https://v2.tauri.app/develop/calling-rust/#:~:text=If%20the%20command%20returns%20an,will%20reject%2C%20otherwise%2C%20it%20resolves)).

**Phase 2: Multi-Agent Features** – _Agent management and coordination_  
\- **Extend to Multiple Agents**: Upgrade the AgentManager to handle a collection of agents (e.g., a HashMap of id \-\> AgentInfo). Implement unique IDs for each agent (could be simple counters or UUIDs). Allow multiple concurrent agents to be started, stopped independently. Update commands and events to reference specific agent IDs. The frontend at this stage should display a list of agents with their statuses (perhaps just in a table or list).  
\- **Inter-Process Communication**: If agents need to talk to each other or to the orchestrator beyond start/stop, implement the necessary channels. For example, if an agent sends a message that affects another, the Rust core can mediate (receive an event from Agent A, then perhaps call a method on Agent B or broadcast an update). This is highly app-specific; ensure the design doesn’t deadlock (e.g., avoid waiting synchronously on one agent from another – use async and events).  
\- **UI Enhancements for Multi-Agent**: Develop the UI to manage multiple agents: ability to add a new agent with some configuration (could be a form), list all running agents with their current state (running, idle, error, etc.), and controls for each (stop/restart buttons). Ensure the UI updates in real time as events come in (this will test the event system under more load – e.g., start 5 dummy agents and see their counters updating via events).  
\- **Background Task Handling**: Introduce any background tasks needed, such as periodic refresh of agent stats if not event-driven. For example, if agents don’t push their CPU usage, the orchestrator could poll every few seconds and emit an update. Implement this carefully to avoid performance issues (maybe use async_runtime::spawn for such loops).

**Phase 3: Advanced Features** – _Real-time visualization and control_  
\- **Real-Time Visualization**: Add features like real-time logs or metrics from agents. This might include a sub-window or panel that streams agent output. Use the patterns from earlier: tail logs and emit events, or implement a ring buffer in Rust that the frontend can request on-demand. Ensure the UI can handle rapid updates (perhaps using virtualization if logs are huge, or auto-scrolling).  
\- **Complex UI Components**: Integrate charts or graphs if needed (e.g., plotting agent performance over time). This will test the ability to handle binary data or lots of data points – consider downsampling data before sending to UI. At this stage, optimize the rendering (e.g., using Canvas/WebGL or an efficient chart library) so that frequent updates do not clog the main thread.  
\- **Inter-Agent Coordination**: Implement orchestration logic like dependencies or triggers between agents (if applicable). For instance, if Agent A must start after Agent B is ready, build that logic into the core and reflect it in the UI (perhaps showing agent dependencies or wait states). This may involve queueing commands or events (e.g., “Agent B started \-\> auto-start Agent A”). Ensure the state machine for agents is well-defined (perhaps use an enum for agent status: Stopped, Starting, Running, Stopping, Error, etc., and only allow certain transitions, updating UI accordingly).  
\- **Security & Permissions**: As features grow, review security. Ensure agents can’t execute arbitrary code beyond what’s intended (especially if you allow user-provided scripts). Use Tauri’s allowlist to disable any APIs not needed. Possibly integrate an auth for sensitive actions (if needed, e.g., if orchestrator manages system services).

**Phase 4: Polish and Optimization** – _Performance and user experience_  
\- **Performance Tuning**: Profile the application with a realistic number of agents. Optimize any hot spots: e.g., if CPU usage is high when many agents run, find out if it’s due to the UI updating too frequently or some busy-wait in Rust. Tune the update frequency or batch events as needed (maybe move from per-agent events to a combined event, or use a more efficient data encoding). The goal is a smooth UI even with many concurrent agents.  
\- **Memory Footprint**: Check memory usage. If the binary is large, consider if some large dependencies are optional. If the app uses \>100MB with many agents, see if that’s mostly the agents themselves (expected) or if the core/UI is retaining data (e.g., very large logs in memory). Implement log rotation or truncation in memory if needed (perhaps keep only last N lines per agent in RAM, while writing full log to disk).  
\- **User Experience Improvements**: Refine the UI – add things like a system tray icon to quickly see status or bring up the app (especially if orchestrator runs continuously). Ensure minimize/close behavior is user-friendly (perhaps default to tray on close, with a setting to change it[\[68\]](https://github.com/zidoro/pomatez#:~:text=%2A%20Minimize%20to%20tray%20,and%20sent%20to%20the%20tray)). Provide notifications for important events (e.g., “Agent X completed task” via system notification – use tauri::api::notification which works cross-platform).  
\- **Auto-Update Integration**: Finally, integrate the auto-updater so users can get new versions easily. Set up publishing of update JSON and test an update flow. This might be last, but it ensures maintenance is easier going forward.

Throughout these phases, maintain **documentation** (maybe in your /docs folder) of the architecture and API, so new developers or contributors understand the structure and message flows.

## Common Pitfalls and Solutions

- **Anti-Pattern: Doing Too Much in the Frontend** – A common pitfall is to implement heavy logic in JavaScript (because it’s familiar) instead of leveraging Rust. This can lead to performance issues and duplicate logic. **Solution**: Offload intensive tasks to Rust commands. For example, parsing large JSON or computing data – do it in Rust and send results to the UI, rather than sending raw data to JS to process. Keep the frontend as a thin layer for presentation and user input, per the control-surface approach[\[7\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=%E2%80%A2%20%201mo%20ago%20,%E2%80%A2%20Edited%201mo%20ago).

- **Global State Mismanagement** – Forgetting to use Tauri’s state and instead relying on front-end singletons can cause out-of-sync issues between windows or lost data on refresh. **Solution**: Use the Tauri State manager to store global state (with Mutex for mutability)[\[29\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=days%20ago%2C%20I%20found%20in,when%20building%20applications%20with%20Tauri)[\[69\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=%2F%2F). Always consider: “Should this piece of data live in Rust or in the UI?” If multiple components or windows need it, or it’s security-critical, it belongs in Rust.

- **Blocking the Main Thread** – Calling a long-running Rust function on the main thread (without async) or doing heavy computation in a render function can freeze the UI. **Solution**: Use async commands (they run on a thread pool)[\[12\]](https://v2.tauri.app/develop/calling-rust/#:~:text=Section%20titled%20%E2%80%9CAsync%20Commands%E2%80%9D) or spawn background threads for heavy work. In the frontend, use requestAnimationFrame or setTimeout for chunking work if needed. Essentially, break tasks into asynchronous pieces so the UI event loop stays free.

- **Excessive IPC Chatter** – Sending extremely frequent messages between front and back (e.g., hundreds of events per second) can overwhelm the system. Signs of this pitfall include high CPU usage in the wrapper process or input lag. **Solution**: Coalesce and throttle IPC messages. If you have rapid data, consider streaming or bulk transfers. Use techniques like debouncing rapid events (collect data for 100ms and send one summary event).

- **Memory Leaks** – Though Rust prevents leaks in its code, the WebView (which is essentially a browser) can leak memory if event listeners accumulate or if huge DOM nodes aren’t freed. **Solution**: Clean up event listeners on unmount (Tauri’s eventListener returns an unlisten function – call it when the component is destroyed). In Rust, be careful with lazy_static or global data – if you store a very large object globally, it will remain for the app lifetime. Also, if using threads, ensure they terminate when not needed (or they will keep their stack and any heap allocations alive).

- **Platform-Specific Bugs** – Pitfall: assuming something that works on one OS works on all. For example, file paths or permission differences, or forgetting that a feature is not available (Wails devs found multi-window wasn’t there yet in Wails[\[70\]](https://dev.to/arashgl/taurirust-vs-wailsgo-4pd6#:~:text=If%20you%27re%20proficient%20in%20Go,still%20under%20development%20in%20Wails)[\[71\]](https://dev.to/arashgl/taurirust-vs-wailsgo-4pd6#:~:text=features%2C%20such%20as%20multi,still%20under%20development%20in%20Wails)). **Solution**: Use Tauri’s documentation and conditional code for platform specifics (e.g., different autostart logic on Mac vs Windows). Test on each platform, especially features like tray, notifications, updater, which involve OS integrations.

- **Deployment Issues** – Code signing on macOS, antivirus false positives on Windows, etc., can be stumbling blocks. **Solution**: Follow Tauri’s guides for signing and use the community knowledge (the Tauri discord and GitHub issues) for solving packaging problems. For instance, make sure the app’s bundle identifier is unique and you have the right certificates for Mac.

- **Over-engineering the Plugin System** – It’s tempting to design a super abstract plugin architecture early, but it can complicate things and delay core features. **Solution**: Build the core functionality in a straightforward way first. If later it becomes clear that plugins are needed (e.g., users want to add their own agent types), then introduce extension points with careful design. Tauri’s own plugin system can be a model (where the core exposes hooks that plugins can register into).

- **Ignoring Security** – A pitfall would be to allow broad access (like not using the allowlist – meaning any JS could call any command, or enabling the shell plugin without validating inputs). **Solution**: Use the tauri.conf.json allowlist to only expose needed APIs and use the tauri::async_runtime and sidecar features carefully. Validate user inputs in Rust (never blindly use a string from the UI as a shell command, for instance). Also, keep dependencies updated (Tauri updates often for security patches).

- **Inadequate Error Handling UX** – Not providing feedback when something fails, leading to silent errors and confused users. **Solution**: Embrace error handling by sending meaningful errors to the UI[\[67\]](https://v2.tauri.app/develop/calling-rust/#:~:text=)[\[72\]](https://v2.tauri.app/develop/calling-rust/#:~:text=%2F%2F%20reject). For example, if an agent fails to start due to a missing file, catch that in Rust, return an Err with a message like "Agent failed to launch: file not found", and have the UI display it (perhaps in a modal or toast). Logging errors to console is good for dev, but users need to know something went wrong in a friendly way.

- **Lack of Testing** – Skipping testing can mean regressions in complex coordination logic. **Solution**: At least test the core Rust logic with different scenarios (start/stop multiple agents, error cases). Use integration tests or a simulated environment to ensure the orchestrator behaves correctly under load (e.g., rapid start/stop commands, or an agent that crashes unexpectedly). This will catch race conditions or deadlocks early.

By being mindful of these pitfalls and applying the solutions and patterns from the Tauri ecosystem, the FORGE Orchestrator can be built with a robust architecture. This ensures a **lightweight, efficient, and scalable** desktop application that leverages the best of Rust for stability and performance, and a modern web UI for a rich user experience.

**Sources:** The recommendations above were informed by real-world Tauri apps and official documentation, including the architecture of Spacedrive (Rust \+ React monorepo with a core library)[\[73\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=Spacedrive%20uses%20the%20%E2%80%9CPRRTT%E2%80%9D%20stack,for%20its%20development%20architecture)[\[47\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=rspc%3A%20The%20project%20utilizes%20rspc%2C,bugs%20making%20it%20into%20production), patterns from Pomatez (productivity app using Tauri for tray, shortcuts, updater)[\[56\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L28-L36)[\[50\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L44-L52), Bruno (React-based API client focusing on local-first storage)[\[74\]](https://wearecommunity.io/communities/javaro/articles/6876#:~:text=...%20wearecommunity.io%20%20Local,stored%20as%20plain%20text%20files), and Tauri’s own guidelines on process model and state management[\[75\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=Each%20Tauri%20application%20has%20a,access%20to%20the%20operating%20system)[\[76\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=The%20Core%20process%20should%20also,prying%20eyes%20in%20the%20Frontend)[\[77\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=days%20ago%2C%20I%20found%20in,when%20building%20applications%20with%20Tauri). These sources, alongside community discussions[\[7\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=%E2%80%A2%20%201mo%20ago%20,%E2%80%A2%20Edited%201mo%20ago)[\[61\]](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6#:~:text=I%20built%20a%20multi,how%20I%20scaled%20it%20cleanly), highlight the best practices that have been incorporated into the design for FORGE Orchestrator.

---

[\[1\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=,a%20variety%20of%20host%20applications) [\[46\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=on%20macOS%2C%20thanks%20to%20Safari%E2%80%99s,integration%20with%20the%20operating%20system) [\[47\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=rspc%3A%20The%20project%20utilizes%20rspc%2C,bugs%20making%20it%20into%20production) [\[55\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=,storage%20capacity%20and%20processing%20power) [\[73\]](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582#:~:text=Spacedrive%20uses%20the%20%E2%80%9CPRRTT%E2%80%9D%20stack,for%20its%20development%20architecture) Spacedrive: A File Explorer from the Future | by StackFoss | Medium

[https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582](https://stackfoss.medium.com/spacedrive-a-file-explorer-from-the-future-45b5732b4582)

[\[2\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=The%20Core%20process%20should%20also,prying%20eyes%20in%20the%20Frontend) [\[39\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=This%20means%20that%20most%20of,framework%20and%20the%20Vite%20bundler) [\[43\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=The%20Core%27s%20primary%20responsibility%20is,messages%20in%20one%20central%20place) [\[48\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=flowchart%20TD%20C,Events%20%26%20Commands%7C%20W3) [\[75\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=Each%20Tauri%20application%20has%20a,access%20to%20the%20operating%20system) [\[76\]](https://v1.tauri.app/v1/references/architecture/process-model/#:~:text=The%20Core%20process%20should%20also,prying%20eyes%20in%20the%20Frontend) Process Model | Tauri v1

[https://v1.tauri.app/v1/references/architecture/process-model/](https://v1.tauri.app/v1/references/architecture/process-model/)

[\[3\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=use%20std%3A%3Async%3A%3AMutex%3B) [\[4\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=%2F%2F%20) [\[5\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=Mutex%20is%20a%20practical%20way,security%20of%20the%20shared%20data) [\[6\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=use%20tauri%3A%3AState%3B) [\[29\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=days%20ago%2C%20I%20found%20in,when%20building%20applications%20with%20Tauri) [\[30\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=Let%27s%20open%20the%20file%20,by%20default%20has%20this%20structure) [\[69\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=%2F%2F) [\[77\]](https://blog.moonguard.dev/manage-state-with-tauri#:~:text=days%20ago%2C%20I%20found%20in,when%20building%20applications%20with%20Tauri) Managing State in Desktop Applications with Rust and Tauri | MoonGuard \- Web Monitoring Tools

[https://blog.moonguard.dev/manage-state-with-tauri](https://blog.moonguard.dev/manage-state-with-tauri)

[\[7\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=%E2%80%A2%20%201mo%20ago%20,%E2%80%A2%20Edited%201mo%20ago) [\[37\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=As%20title%20states%2C%20I%E2%80%99m%20building,I%20have) [\[38\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=ferreira) [\[60\]](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/#:~:text=using%20and%20communicating%20it%20with,Thank%20you%20in) State management options : r/tauri

[https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/](https://www.reddit.com/r/tauri/comments/1lvwi1k/state_management_options/)

[\[8\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L26-L34) [\[9\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L156-L165) [\[10\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L232-L240) [\[11\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L234-L242) [\[44\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L240-L248) [\[52\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L34-L42) [\[53\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L44-L50) [\[54\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs#L42-L50) commands.rs

[https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/commands.rs)

[\[12\]](https://v2.tauri.app/develop/calling-rust/#:~:text=Section%20titled%20%E2%80%9CAsync%20Commands%E2%80%9D) [\[13\]](https://v2.tauri.app/develop/calling-rust/#:~:text=Note) [\[14\]](https://v2.tauri.app/develop/calling-rust/#:~:text=If%20your%20command%20needs%20to,async) [\[15\]](https://v2.tauri.app/develop/calling-rust/#:~:text=If%20the%20command%20returns%20an,will%20reject%2C%20otherwise%2C%20it%20resolves) [\[16\]](https://v2.tauri.app/develop/calling-rust/#:~:text=serde%3A%3ASerialize%2C%20including%20errors,String) [\[17\]](https://v2.tauri.app/develop/calling-rust/#:~:text=%2F%2F%20create%20the%20error%20type,errors%20possible%20in%20our%20program) [\[18\]](https://v2.tauri.app/develop/calling-rust/#:~:text=fn%20my_custom_command%28%29%20,) [\[19\]](https://v2.tauri.app/develop/calling-rust/#:~:text=enum%20Error%20) [\[20\]](https://v2.tauri.app/develop/calling-rust/#:~:text=) [\[21\]](https://v2.tauri.app/develop/calling-rust/#:~:text=fn%20read%28%29%20,) [\[41\]](https://v2.tauri.app/develop/calling-rust/#:~:text=fn%20read_file%28%29%20) [\[42\]](https://v2.tauri.app/develop/calling-rust/#:~:text=If%20your%20handler%20could%20fail,Result) [\[67\]](https://v2.tauri.app/develop/calling-rust/#:~:text=) [\[72\]](https://v2.tauri.app/develop/calling-rust/#:~:text=%2F%2F%20reject) Calling Rust from the Frontend | Tauri

[https://v2.tauri.app/develop/calling-rust/](https://v2.tauri.app/develop/calling-rust/)

[\[22\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=let%20twitch_chat_app_handler%20%3D%20handle) [\[23\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=) [\[24\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=) [\[25\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=let%20join_handle%20%3D%20async_runtime%3A%3Aspawn,) [\[34\]](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2#:~:text=) Long-running backend async tasks in tauri v2 \- sneaky crow

[https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2](https://sneakycrow.dev/blog/2024-05-12-running-async-tasks-in-tauri-v2)

[\[26\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=One%20of%20Orion%27s%20key%20features,an%20ideal%20choice%20for%20Orion) [\[27\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=To%20handle%20the%20creation%20and,file%20with%20the%20following%20functions) [\[28\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=the%C2%A0,Here%27s%20how%20to%20do%20it) [\[32\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=fn%20create_db_file%28%29%20,unwrap) [\[33\]](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri#:~:text=mod%20db%3B) How to use local SQLite database with Tauri and Rust | MoonGuard \- Web Monitoring Tools

[https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri](https://blog.moonguard.dev/how-to-use-local-sqlite-database-with-tauri)

[\[31\]](https://crates.io/crates/tauri-plugin-state#:~:text=tauri,to%20keep%20it%20in%20sync) tauri-plugin-state \- crates.io: Rust Package Registry

[https://crates.io/crates/tauri-plugin-state](https://crates.io/crates/tauri-plugin-state)

[\[35\]](https://github.com/tauri-apps/tauri/issues/4949#:~:text=,child%20process%20continues%20to%20run) \[bug\] spawned children cannot be killed under windows · Issue \#4949

[https://github.com/tauri-apps/tauri/issues/4949](https://github.com/tauri-apps/tauri/issues/4949)

[\[36\]](https://v2.tauri.app/concept/architecture/#:~:text=,121) [\[45\]](https://v2.tauri.app/concept/architecture/#:~:text=,About) [\[64\]](https://v2.tauri.app/concept/architecture/#:~:text=Section%20titled%20%E2%80%9Ctauri) Tauri Architecture | Tauri

[https://v2.tauri.app/concept/architecture/](https://v2.tauri.app/concept/architecture/)

[\[40\]](https://github.com/zidoro/pomatez#:~:text=%2A%20Progress%20animation%20,disable%20it%20by%20the%20way) [\[51\]](https://github.com/zidoro/pomatez#:~:text=running%20on%20your%20Operating%20System) [\[68\]](https://github.com/zidoro/pomatez#:~:text=%2A%20Minimize%20to%20tray%20,and%20sent%20to%20the%20tray) GitHub \- zidoro/pomatez: Stay Focused. Take a Break.

[https://github.com/zidoro/pomatez](https://github.com/zidoro/pomatez)

[\[49\]](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6#:~:text=Most%20desktop%20apps%20fail%20to,scale%20because) [\[61\]](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6#:~:text=I%20built%20a%20multi,how%20I%20scaled%20it%20cleanly) [\[62\]](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6#:~:text=So%20in%202025%2C%20when%20I,and%20I%20haven%E2%80%99t%20looked%20back) [\[63\]](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6#:~:text=With%20just%20Rust%20%2B%20HTML%2FCSS%2FJS%2C,scales%20like%20a%20native%20app) Tauri at Scale: Building Multi-Window Desktop Apps Without the Bloat | by Nikulsinh Rajput | Aug, 2025 | Medium

[https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6](https://medium.com/@hadiyolworld007/tauri-at-scale-building-multi-window-desktop-apps-without-the-bloat-e17676b906c6)

[\[50\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L44-L52) [\[56\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L28-L36) [\[57\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L30-L37) [\[58\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L58-L66) [\[59\]](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs#L38-L46) main.rs

[https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs](https://github.com/zidoro/pomatez/blob/c3af3429276f8d4bbea69b689afc7a46bf0d6589/app/tauri/src/main.rs)

[\[65\]](https://v2.tauri.app/develop/tests/webdriver/ci/#:~:text=Continuous%20Integration%20,built%20together%20and%20GitHub) Continuous Integration \- Tauri

[https://v2.tauri.app/develop/tests/webdriver/ci/](https://v2.tauri.app/develop/tests/webdriver/ci/)

[\[66\]](https://v2.tauri.app/distribute/pipelines/github/#:~:text=GitHub%20,query%20the%20newly%20created) GitHub \- Tauri

[https://v2.tauri.app/distribute/pipelines/github/](https://v2.tauri.app/distribute/pipelines/github/)

[\[70\]](https://dev.to/arashgl/taurirust-vs-wailsgo-4pd6#:~:text=If%20you%27re%20proficient%20in%20Go,still%20under%20development%20in%20Wails) [\[71\]](https://dev.to/arashgl/taurirust-vs-wailsgo-4pd6#:~:text=features%2C%20such%20as%20multi,still%20under%20development%20in%20Wails) Tauri(rust) vs Wails(go) \- DEV Community

[https://dev.to/arashgl/taurirust-vs-wailsgo-4pd6](https://dev.to/arashgl/taurirust-vs-wailsgo-4pd6)

[\[74\]](https://wearecommunity.io/communities/javaro/articles/6876#:~:text=...%20wearecommunity.io%20%20Local,stored%20as%20plain%20text%20files) Replacing Postman with Bruno: A Developer-Friendly API Client ...

[https://wearecommunity.io/communities/javaro/articles/6876](https://wearecommunity.io/communities/javaro/articles/6876)
